dinCachePlugin for Symfony 1.3/1.4
==================================

Документацию на английском смотрите в README.md

Краткая информация о плагине
----------------------------
Плагин предназначен для реализации «умного» кеширования.
Суть метода состоит в том, что кеш удаляется только при изменении в оригинальных данных. Для этого
используется система правил, похожая на роутинг. В правиле описываются все зависимости данных,
формирование ключей и путей, выбор кеширующего механизма и другие настройки. Сам менеджер кеша
работает как прокси, все запросы данных адресуются ему, а он уже либо берет данные из кеша, либо сам
запрашивает их у ORM.

Когда через менеджер кеша запрашиваются данные по определенному ключу (названию правила), он
проверяет, есть ли такие данные в кеше. Если данные есть - они отдаются. Если нет - на основании
правила делается запрос к модели ORM, полученные данные обрабатываются в зависимости от типа и
сохраняются в кеше. Когда в каком-либо объекте какой-либо модели что-либо меняется (добавляется
новый, удаляется или модифицируется существующий), это событие перехватывается слушателем менеджера.
Менеджер команду обрабатывает и в случае нахождения подходящих правил - удаляет
все связанные с объектом закешированные данные.

Основные достоинства
--------------------
* Благодаря своей легкости и отсутствию необходимости загружать ORM при наличии данных в кеше экономит массу ресурсов
* Время жизни кеша ограничено только его актуальностью - пока частично или полностью не изменятся оригинальные данные
* Гибкое управление кешированием данных при помощи конфигурационного файла в yml

Текущие ограничения
--------------------
* На данный момент поддерживается работа только с ORM Doctrine 1.2
* На данный момент протестирована работа только с файловым кешем

Зависимости
-----------
* [Symfony](http://www.symfony-project.org/) 1.3/1.4
* [Doctrine](http://www.doctrine-project.org/) 1.2

Установка
---------
Для удобства менеджер включается в состав доступных через sfContext объектов.
Это требует добавления трех строк в метод setup() файла ProjectConfiguration.class.php:

    $pldir = sfConfig::get( 'sf_plugins_dir' );
    require_once( $pldir . '/dinCachePlugin/lib/config/dinCacheRoutingConfigHandler.php' );
    require_once( $pldir . '/dinCachePlugin/lib/config/dinFactoryConfigHandler.php' );

Сюда же надо добавить еще один метод для подключения слушателя:

    public function configureDoctrineConnection( Doctrine_Connection $conn )
    {
        $conn->addRecordListener( new dinCacheDoctrineListener( $conn ) );
    }

*При использовании в проекте плагина dinSymfonyExtraPlugin эти операции выполнять не нужно*

Далее требуется отредактировать (или создать пустой) файл config_handlers.yml в директории config
в вашем приложении, заменив там (или добавив) обработчик для конфигурации фабрик:

    'config/factories.yml':
        class:          'dinFactoryConfigHandler'

и добавив туда же ниже обработчик для конфигурации менеджера кеша:

    'config/cache_routing.yml':
        class:          'dinCacheRoutingConfigHandler'


Также следует добавить в конфигурационный файл factories.yml вашего приложения следующий блок:

    cache_manager:
        class:                  'dinCacheManager'
        param:
            load_configuration: true
            defaults:
                ttl:            '157680000'
                driver:         'sfFileCache'
                ipf:            '1'

*добавлять логичнее всего для всех окружений (all)*

На этом установку менеджера можно считать законченной.

Настройка
---------
В плагине есть базовая настройка для основных типов данных: data, page и choices.
Типы необходимы для более удобной работы с данными.
Менеджер различает следующие типы данных:

1. **data** – хранение одного объекта по id. Если в правиле установить параметр ipf отличный от 1, то
в одном хранилище (файле) будет размещаться указанное количество объектов. Также отличается там, что
данные отдаются в виде массива данных одного объекта, а не массива массовов данных объекта.

2. **page** - служит для кеширования постраничных данных

3. **choices** - служит для кеширования списков значений (для селектов например). Отличается тем, что
выбирается и сохраняется только пара id/title.

4. **custom** - для кеширования произвольных выборок из БД.

5. **prepared** - кеширование подготовленных данных. Отличается тем, что получает из модели данные в
конечном виде, ничего с ними не делает, просто сохраняет в кеше и отдает. Для всех остальных типов
менеджер получает из модели объект Doctrine_Query и сам выбирает данные.

Теперь вы можете заняться написанием правил для кеширования нужных вам данных и линковкой к ним моделей.

Прежде всего надо создать файл cache_routing.yml в папке config проекта. В нем необходимо создать
два раздела: **routes** и **links**.
Так выглядит стандартное правило:

    routes:
        rule_name:
            type:           'custom' #or others: data, page, choices etc.
            get:
                model:      'model_name'
                method:     'method_name'
                path:       ':_root/model_name/route_name'
                key:        ':field_name.:other_field_name.:_i18n.cache'
            remove:
                default:
                    path:   ':_root/model_name/route_name'
                    key:    ':field_name.:other_field_name.*.cache'

Теперь конкретнее по элементам в правиле.

**rule_name** - соответственно название правила, по которому будет происходить запрос данных.

**get** - секция описывает правила для выборки и хранения кеша.

**model** и **method** - соответственно указывают, к какой модели обращаться и какой метод
запрашивать для получения исходных данных.

**path** - путь, по которому будет находиться кеш.

И в пути, и в ключе поддерживаются следующие подстановки:

**:_model** - название текущей модели.

**:_type** - тип данных (data, page, choices etc.)

**:_root** - указание на корневую директорию для хранения данных кеша (по умолчанию это cache/data в проекте).

**:_i18n** - если модель имеет i18n данные - этот ключ подставляет текущий язык.

Также в пути и ключе может присутствовать название любого поля, по которому производится выборка.
Собственно по этим полям и будет осуществляться поиск и удаление кеша.

Нецифровые ключи будут преобразованы в md5 хеши, цифровые в путях будут разбиты на 3 подпапки, чтобы
исключить хранение в одной папке более 10 тысяч файлов с кешем.

**remove** - секция описывает правила удаления кеша.

В путях и ключах поддерживаются подстановки и «*», которой можно заменять любое количество полей.

Вместо **default** можно указать конкретное название модели. Это полезно, поскольку для разных моделей
могут быть разные пути и ключи (например в обычной модели категорий ключ category_id отсутствует,
зато есть ключ id, означающий то же самое).


Дополнительно в секции get доступны следующие ключи:

**_no_prepare_translations** - можно указать, если не требуется перемещать переводы из многомерного
массива Translation (в этом случае у объектов с i18n будет ключ Translation с массивом переводов).
Достаточно наличие самого параметра, его значение никакой разницы в действии не оказывает, логично
выставлять в true.

**join** - только для типа данных choices, позволяет получить многомерный список вида категория/объект.
Валидным значением является алиас форейгн-ключа в основной модели.

**ttl** - время жизни кеша в секундах (по умолчанию 157680000, что равно одному году)

**driver** - драйвер для кеширования (по умолчанию - sfFileCache, можно использовать любые доступные
в Symfony драйвера кеширующих механизмов). Эта опция пока не тестировалась!

**ipf** - только для типа data, позволяет хранить в одном хранилище (файле) указанное количество объектов.

Таким образом модели линкуются к правилам:

    links:
        model_name:     ['route_name']

Если модель не прилинкована - то при изменении в объекте этой модели кеш из этого правила не будет удален.
Если к правилу не привязана основная модель, из которой происходит выборка данных - будет выброшено исключение.

Пару слов о требованиях к методам, с помощью которых осуществляются выборки данных.
Все методы обязаны принимать первым аргументом массив ключей, нужных для выборки. Все методы, кроме
правил типа prepared обязаны возвращать объект Doctrine_Query. Для prepared должен возвращаться
массив данных или объект/коллекция.

Вот шаблон для метода выборки (размещается естественно в классе таблицы нужной модели):

    public function method_name( $params )
    {
        $q = $this->createQuery();

        *** условия с данными из $params и т.д.

        return $q;
    }

Использование
-------------
В контроллере вы можете обращаться к менеджеру следующим образом:

    $data = $this->getContext()->get( 'cache_manager' )->getContent(
        'rule_name', 'model_name', array( 'field_name' => value )
    );

*При использовании в проекте плагина dinSymfonyExtraPlugin объект менеджера доступен сразу в контроллере*

Собственно все.

Список задач
------------
1. Добавить поддержку Propel ORM
2. Добавить поддержку произвольных источников данных
3. Добавить поддержку различных кеширующих механизмов
4. Перевести на работу в качестве сервиса
5. Покрыть тестами
6. Добавить в официальный репозитарий Symfony
7. Выделить плагин в независимый компонент для использования вне фреймворка Symfony, а также в Symfony 2